# Python Skill

> Versatile programming language for web, data, automation, and AI

## When to Use

Use this skill when working with Python projects, scripts, or backend services.

## Key Concepts

| Concept | Description | Use Case |
|---------|-------------|----------|
| Virtual Environments | Isolated package installations | Project dependencies |
| Type Hints | Optional static typing | Code clarity, IDE support |
| Async/Await | Asynchronous programming | I/O bound operations |
| Decorators | Function/class modifiers | Logging, auth, caching |
| Context Managers | Resource management | Files, connections |

## Project Setup

```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# Install dependencies
pip install -r requirements.txt

# Freeze dependencies
pip freeze > requirements.txt
```

## Type Hints

```python
from typing import Optional, List, Dict, Union, Callable

def greet(name: str, times: int = 1) -> str:
    return f"Hello, {name}! " * times

def process_items(items: List[str]) -> Dict[str, int]:
    return {item: len(item) for item in items}

def fetch_user(user_id: int) -> Optional[User]:
    """Returns None if user not found."""
    return db.get(user_id)

# Union types
def parse(value: Union[str, int]) -> str:
    return str(value)

# Python 3.10+ syntax
def parse(value: str | int) -> str:
    return str(value)
```

## Async Programming

```python
import asyncio
import aiohttp

async def fetch_data(url: str) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()

async def fetch_all(urls: list[str]) -> list[dict]:
    tasks = [fetch_data(url) for url in urls]
    return await asyncio.gather(*tasks)

# Run async code
asyncio.run(fetch_all(["https://api.example.com/1", "https://api.example.com/2"]))
```

## Common Patterns

```python
# Context manager
with open("file.txt", "r") as f:
    content = f.read()

# Custom context manager
from contextlib import contextmanager

@contextmanager
def timer():
    start = time.time()
    yield
    print(f"Elapsed: {time.time() - start:.2f}s")

# Decorator
from functools import wraps

def log_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

# Dataclass
from dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str
    email: str
    active: bool = True
```

## Pitfalls

- Use virtual environments for every project
- Don't use mutable default arguments (`def foo(items=[])`)
- Remember `async` functions need `await`
- Use `is` for None comparison, `==` for values
- Handle exceptions specifically, not bare `except:`

## Context7

```
mcp__context7__resolve-library-id with "python"
mcp__context7__query-docs for specific Python questions
```

---

Generated by SuperAgents
