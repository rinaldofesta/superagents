# MCP (Model Context Protocol) Skill

> Open protocol for connecting AI assistants to external tools and data sources

## When to Use

Use this skill when building MCP servers to expose tools, resources, or prompts to AI assistants like Claude.

## Key Concepts

| Concept | Description | Use Case |
|---------|-------------|----------|
| Tools | Executable functions | API calls, computations |
| Resources | Data sources | Files, databases, APIs |
| Prompts | Reusable templates | Guided interactions |
| Server | MCP implementation | Expose capabilities |
| Transport | Communication layer | stdio, HTTP, WebSocket |

## MCP Server (TypeScript)

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server(
  { name: "my-mcp-server", version: "1.0.0" },
  { capabilities: { tools: {}, resources: {} } }
);

// Define a tool
server.setRequestHandler("tools/list", async () => ({
  tools: [{
    name: "get_weather",
    description: "Get weather for a location",
    inputSchema: {
      type: "object",
      properties: {
        location: { type: "string", description: "City name" }
      },
      required: ["location"]
    }
  }]
}));

// Handle tool calls
server.setRequestHandler("tools/call", async (request) => {
  if (request.params.name === "get_weather") {
    const { location } = request.params.arguments;
    const weather = await fetchWeather(location);
    return { content: [{ type: "text", text: JSON.stringify(weather) }] };
  }
  throw new Error(`Unknown tool: ${request.params.name}`);
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

## MCP Server (Python with FastMCP)

```python
from fastmcp import FastMCP

mcp = FastMCP("my-mcp-server")

@mcp.tool()
def get_weather(location: str) -> str:
    """Get current weather for a location.

    Args:
        location: City name to get weather for
    """
    # Fetch weather data
    return f"Weather in {location}: 72Â°F, Sunny"

@mcp.tool()
def search_database(query: str, limit: int = 10) -> list[dict]:
    """Search the database for matching records.

    Args:
        query: Search query string
        limit: Maximum results to return
    """
    results = db.search(query, limit=limit)
    return results

@mcp.resource("file://{path}")
def read_file(path: str) -> str:
    """Read contents of a file."""
    with open(path) as f:
        return f.read()

@mcp.prompt()
def code_review_prompt(code: str, language: str) -> str:
    """Generate a code review prompt."""
    return f"Review this {language} code:\n\n```{language}\n{code}\n```"

if __name__ == "__main__":
    mcp.run()
```

## Claude Desktop Configuration

```json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["/path/to/server/index.js"],
      "env": {
        "API_KEY": "your-api-key"
      }
    },
    "python-server": {
      "command": "python",
      "args": ["/path/to/server.py"]
    }
  }
}
```

## Tool Design Best Practices

```typescript
// Good: Clear name, description, typed parameters
{
  name: "create_github_issue",
  description: "Create a new issue in a GitHub repository",
  inputSchema: {
    type: "object",
    properties: {
      repo: {
        type: "string",
        description: "Repository in format owner/repo"
      },
      title: {
        type: "string",
        description: "Issue title"
      },
      body: {
        type: "string",
        description: "Issue body (markdown supported)"
      },
      labels: {
        type: "array",
        items: { type: "string" },
        description: "Labels to apply"
      }
    },
    required: ["repo", "title"]
  }
}
```

## Error Handling

```typescript
server.setRequestHandler("tools/call", async (request) => {
  try {
    const result = await executeTool(request.params);
    return { content: [{ type: "text", text: result }] };
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: `Error: ${error.message}`
      }],
      isError: true
    };
  }
});
```

## Pitfalls

- Always validate tool inputs before execution
- Return clear error messages for debugging
- Use descriptive tool names and descriptions
- Keep tools focused on single responsibilities
- Handle timeouts for long-running operations
- Test with Claude Desktop before deployment

## Context7

```
mcp__context7__resolve-library-id with "mcp"
mcp__context7__query-docs for specific MCP questions
```

---

Generated by SuperAgents
