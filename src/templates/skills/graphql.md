# GraphQL Skill

> Query language for APIs with strong typing and introspection

## When to Use

Use this skill when building or consuming GraphQL APIs.

## Key Concepts

| Concept | Description | Use Case |
|---------|-------------|----------|
| Schema | Type definitions | API contract |
| Queries | Read operations | Fetch data |
| Mutations | Write operations | Create/Update/Delete |
| Resolvers | Field resolution logic | Data fetching |
| Subscriptions | Real-time updates | Live data |

## Schema Definition

```graphql
type User {
  id: ID!
  email: String!
  name: String
  posts: [Post!]!
  createdAt: DateTime!
}

type Post {
  id: ID!
  title: String!
  content: String
  published: Boolean!
  author: User!
}

type Query {
  user(id: ID!): User
  users(limit: Int, offset: Int): [User!]!
  post(id: ID!): Post
}

type Mutation {
  createUser(email: String!, name: String): User!
  updateUser(id: ID!, name: String): User
  deleteUser(id: ID!): Boolean!
  createPost(title: String!, content: String, authorId: ID!): Post!
}

type Subscription {
  postCreated: Post!
}
```

## Query Examples

```graphql
# Basic query
query GetUser {
  user(id: "1") {
    id
    name
    email
  }
}

# Query with variables
query GetUsers($limit: Int!) {
  users(limit: $limit) {
    id
    name
    posts {
      title
    }
  }
}

# Mutation
mutation CreatePost($input: CreatePostInput!) {
  createPost(input: $input) {
    id
    title
  }
}

# Fragment for reusable fields
fragment UserFields on User {
  id
  name
  email
}

query {
  user(id: "1") {
    ...UserFields
  }
}
```

## Resolver Pattern

```typescript
const resolvers = {
  Query: {
    user: (_, { id }, context) => {
      return context.db.user.findUnique({ where: { id } })
    },
    users: (_, { limit, offset }, context) => {
      return context.db.user.findMany({ take: limit, skip: offset })
    },
  },
  Mutation: {
    createUser: (_, { email, name }, context) => {
      return context.db.user.create({ data: { email, name } })
    },
  },
  User: {
    posts: (parent, _, context) => {
      return context.db.post.findMany({ where: { authorId: parent.id } })
    },
  },
}
```

## Client Usage

```typescript
// Apollo Client
const { data, loading, error } = useQuery(GET_USER, {
  variables: { id: '1' }
})

// Mutation
const [createPost] = useMutation(CREATE_POST, {
  onCompleted: (data) => console.log('Created:', data),
  refetchQueries: ['GetPosts'],
})
```

## Pitfalls

- N+1 problem: Use DataLoader for batching
- Over-fetching: Request only needed fields
- Security: Implement depth limiting, query complexity
- Caching: Use Apollo cache or similar

## Context7

```
mcp__context7__resolve-library-id with "graphql"
mcp__context7__query-docs for specific GraphQL questions
```

---

Generated by SuperAgents
